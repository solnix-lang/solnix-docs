{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Solnix - Minimal DSL for eBPF","text":"<ul> <li>ebpf</li> <li>compiler</li> <li>rust</li> </ul>"},{"location":"#solnix","title":"Solnix","text":"<p>A minimal domain-specific language for writing safe and structured eBPF programs.</p> <p>Solnix compiles to C and targets the Linux eBPF subsystem.</p>"},{"location":"#why-solnix","title":"Why Solnix","text":"<ul> <li>Structured syntax for eBPF programs</li> <li>Safer memory access</li> <li>Clean event-driven design</li> <li>Generates verifier-friendly C code</li> </ul>"},{"location":"#example","title":"Example","text":"<pre><code>map events {\n    type: .ringbuf,\n    max: 1 &lt;&lt; 24\n}\n\nevent exec_event {\n    pid: u32,\n    filename: bytes[256]\n}\n\nunit trace_exec {\n    section \"tracepoint/syscalls/sys_enter_execve\"\n    license \"GPL\"\n\n    reg pid_tgid = ctx.get_pid_tgid()\n    reg pid = pid_tgid\n\n    reg filename_ptr = ctx.load_u64(ctx + 16)\n    ctx.probe_read_user_str(exec_event.filename, 256, filename_ptr)\n\n    events.emit(exec_event)\n}\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Language Guide</li> <li>eBPF Model</li> <li>Installation</li> <li>Examples</li> </ul>"},{"location":"#design-goals","title":"Design Goals","text":"<ul> <li>Minimal surface area</li> <li>Predictable memory model</li> <li>Verifier-safe abstractions</li> <li>No hidden runtime</li> </ul>"},{"location":"#status","title":"Status","text":"<p>Solnix is under active development.</p> <p>APIs may change until v1.0.*</p>"},{"location":"compiler/architecture/","title":"Architecture","text":""},{"location":"compiler/architecture/#pipeline-design","title":"Pipeline Design","text":"<pre><code>graph TD\n    A[\"Solnix Source Code\"] --&gt; B[\"Lexer + Parser\"]\n    B --&gt; C[\"AST Builder\"]\n    C --&gt; D[\"Semantic Safety Validator (eBPF rules)\"]\n    D --&gt; E[\"Intermediate Representation (IR)\"]\n    E --&gt; F[\"C Code Backend Generator\"]\n    F --&gt; G[\"Generate .o Object File\"]</code></pre>"},{"location":"compiler/architecture/#backend-strategy","title":"Backend Strategy","text":"<ul> <li>Compiler directly emits C source code  </li> <li>Kernel eBPF program struct and logic are generated in C  </li> <li>Lightweight translation layer only    </li> </ul>"},{"location":"compiler/architecture/#implementation-stack","title":"Implementation Stack","text":"<ul> <li>Compiler Core \u2192 Rust  </li> <li>Output Target \u2192  C backend code  </li> <li>Verification \u2192 Built-in Solnix safety checker</li> </ul>"},{"location":"compiler/architecture/#help-us-build-solnix","title":"Help Us Build Solnix","text":"<p>Interested in working on the parser, IR, or backend? Check out our Compiler Contribution Guide to get started!</p>"},{"location":"compiler/codegen/","title":"Code Generation Engine","text":""},{"location":"compiler/codegen/#purpose","title":"Purpose","text":"<p>Solnix code generator translates AST / IR nodes directly into C backend source code for eBPF execution.</p>"},{"location":"compiler/codegen/#codegen-workflow","title":"Codegen Workflow","text":"<pre><code>graph TD\n    A[\"AST Node Stream\"] --&gt; B[\"Pattern Matcher\"]\n    B --&gt; C[\"IR Instruction Mapping\"]\n    C --&gt; D[\"C Backend Template Renderer\"]\n    D --&gt; E[\"Emit Kernel-Ready C Program\"]</code></pre>"},{"location":"compiler/codegen/#code-emission-model","title":"Code Emission Model","text":""},{"location":"compiler/codegen/#function-generation","title":"Function Generation","text":"<ul> <li>Each Solnix function is converted into a C function block  </li> <li>Entry hooks are mapped to eBPF program entry points  </li> <li>Control flow is expanded into C logic statements  </li> </ul>"},{"location":"compiler/codegen/#program-structure-output","title":"Program Structure Output","text":"<p>Generated code contains:</p> <ul> <li>Map declarations  </li> <li>Program entry handlers  </li> <li>Instruction execution body  </li> <li>Return path validator  </li> </ul>"},{"location":"compiler/codegen/#safety-rules-during-codegen","title":"Safety Rules During Codegen","text":"<ul> <li>Reject unsafe memory access patterns  </li> <li>Validate loop constructs  </li> <li>Check register allocation consistency  </li> <li>Verify kernel verifier compatibility  </li> </ul>"},{"location":"compiler/codegen/#backend-format","title":"Backend Format","text":"<p>Output =  C source file</p>"},{"location":"compiler/ir-design/","title":"IR Design","text":""},{"location":"compiler/ir-design/#overview","title":"Overview","text":"<p>Solnix IR is a lightweight internal compiler representation used between the parsing phase and C backend code generation. It provides a formal structure that allows the compiler to perform optimizations and safety checks without being tied to the high-level syntax of the source code or the low-level details of the C backend.</p> <p>The IR layer is inspired by compiler infrastructure concepts similar to the LLVM Project, but Solnix IR is intentionally simpler and deterministic for kernel-level execution safety. By maintaining a strict, non-ambiguous format, the IR ensures that every instruction can be statically verified against eBPF verifier constraints before any code is emitted.</p> <p>IR is not exposed to developers. It is only used inside the compiler pipeline.</p>"},{"location":"compiler/ir-design/#role-of-ir-in-compiler-pipeline","title":"Role of IR in Compiler Pipeline","text":"<pre><code>graph TD\n    A[\"Source Code\"] --&gt; B[\"Lexer + Parser\"]\n    B --&gt; C[\"AST Builder\"]\n    C --&gt; D[\"IR Construction Layer\"]\n    D --&gt; E[\"IR Validator &amp; Analyzer\"]\n    E --&gt; F[\"Code Generator (C Backend)\"]</code></pre>"},{"location":"compiler/ir-design/#design-philosophy","title":"Design Philosophy","text":"<ul> <li>SSA (Static Single Assignment) Lite: Solnix utilizes a simplified SSA form to track data flow efficiently while keeping the compiler footprint small.</li> <li>Direct Mapping: Every IR instruction has a predictable mapping to eBPF-compatible C constructs to prevent \"hidden\" complexity.</li> <li>Safety First: The validator runs directly on the IR to catch out-of-bounds access and infinite loops early in the build process.</li> </ul>"},{"location":"compiler/ir-design/#dive-into-the-ir","title":"Dive into the IR","text":"<p>Want to help optimize our intermediate representation? Check out the Compiler Contribution Guide.</p>"},{"location":"contributing/compiler-contrib/","title":"Compiler Contribution Guide","text":"<p>Welcome to the Solnix Compiler development team! This guide provides the necessary information to help you contribute to the core heart of the Solnix language.</p>"},{"location":"contributing/compiler-contrib/#overview","title":"Overview","text":"<p>The Solnix compiler is written in Rust and acts as a high-performance bridge between Solnix source code and eBPF-compatible C code. Our goal is to provide a safe, expressive, and efficient way to write kernel-level logic.</p>"},{"location":"contributing/compiler-contrib/#the-pipeline","title":"The Pipeline","text":"<ol> <li>Frontend: Lexing and Parsing (Source \u2192 AST)</li> <li>Analysis: Semantic Validation and Type Checking</li> <li>Safety Engine: eBPF boundary verification</li> <li>Backend: IR generation and C Code Emission</li> </ol>"},{"location":"contributing/compiler-contrib/#getting-started","title":"Getting Started","text":""},{"location":"contributing/compiler-contrib/#prerequisites","title":"Prerequisites","text":"<p>To build and test the compiler, you will need: - Rust Toolchain: Install Rust (Stable channel) - Clang/LLVM: Version 11+ (Required for eBPF object verification) - libbpf: Development headers</p>"},{"location":"contributing/compiler-contrib/#setting-up-the-environment","title":"Setting Up the Environment","text":"<ol> <li>Clone the main repository:    <pre><code>git clone https://github.com/solnix/solnix.git\ncd solnix\n</code></pre></li> <li>Build the compiler in debug mode:    <pre><code>cargo build\n</code></pre></li> </ol>"},{"location":"contributing/compiler-contrib/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributing/compiler-contrib/#adding-a-new-feature","title":"Adding a New Feature","text":"<ol> <li>Syntax: Define the new syntax in <code>ast/mod.rs</code> and update the <code>parser</code>.</li> <li>Semantics: Add type checking logic in <code>sema/</code>.</li> <li>Safety: Ensure the feature respects eBPF stack limits and instruction counts.</li> <li>Codegen: Implement the C emission logic in <code>codegen/</code>.</li> <li>Tests: Add a regression test in <code>tests/</code>.</li> </ol>"},{"location":"contributing/compiler-contrib/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Always include a reproduction script in your PR.</li> <li>Ensure that <code>cargo test</code> passes across all supported architectures.</li> </ul>"},{"location":"contributing/compiler-contrib/#coding-standards","title":"Coding Standards","text":"<ul> <li>Safety First: Use <code>unsafe</code> sparingly and only with documented justification.</li> <li>Performance: Solnix is a systems language; avoid unnecessary allocations in the hot path.</li> <li>Documentation: All public API functions must have doc comments (<code>///</code>).</li> <li>Idiomatic Rust: Follow Rust API Guidelines.</li> </ul>"},{"location":"contributing/compiler-contrib/#testing-checklist","title":"Testing Checklist","text":"<p>Before submitting a Pull Request, ensure: - [ ] Code is formatted with <code>cargo fmt</code>. - [ ] No new <code>clippy</code> warnings are introduced. - [ ] All unit and integration tests are passing. - [ ] You have added documentation for new flags or features.</p> <p>Need help? Join our [Discord/Slack] or open an issue on GitHub!</p>"},{"location":"contributing/docs-contrib/","title":"Documentation Contribution Guide","text":"<p>Thank you for your interest in improving the Solnix documentation! High-quality docs are essential for a professional programming language.</p>"},{"location":"contributing/docs-contrib/#getting-started","title":"Getting Started","text":"<p>Solnix documentation is built using MkDocs with the Material theme. All content is written in Markdown.</p>"},{"location":"contributing/docs-contrib/#contribution-workflow","title":"Contribution Workflow","text":"<p>Fork Repo \u2192 Create Branch \u2192 Edit .md Files \u2192 Local Preview \u2192 Submit PR</p>"},{"location":"contributing/docs-contrib/#documentation-style","title":"Documentation Style","text":"<ul> <li>Clarity: Use simple, direct language. Avoid jargon where possible.</li> <li>Consistency: Follow the existing terminology and formatting.</li> <li>Examples: Include code snippets for all technical concepts.</li> <li>Visuals: Use Mermaid diagrams for architecture or workflows.</li> </ul>"},{"location":"contributing/docs-contrib/#setting-up-locally","title":"Setting Up Locally","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/solnix/solnix-docs.git\ncd solnix-docs\n</code></pre></p> </li> <li> <p>Install dependencies:    <pre><code>pip install mkdocs-material\n</code></pre></p> </li> <li> <p>Serve the site:    <pre><code>mkdocs serve\n</code></pre>    Open <code>http://localhost:8000</code> in your browser to see live changes.</p> </li> </ol>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>Consistency is key to maintaining a high-quality codebase and documentation. This guide outlines the conventions we use at Solnix.</p>"},{"location":"contributing/style-guide/#rust-code-style","title":"Rust Code Style","text":"<p>We follow the standard Rust conventions. When in doubt, let the tools decide.</p>"},{"location":"contributing/style-guide/#tools","title":"Tools","text":"<ul> <li>Formatting: Always use <code>cargo fmt</code>.</li> <li>Linting: We use <code>clippy</code> for catch common mistakes. Run <code>cargo clippy</code> and ensure it's clean.</li> </ul>"},{"location":"contributing/style-guide/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Types/Traits: <code>PascalCase</code> (e.g., <code>ProgramContext</code>)</li> <li>Functions/Variables: <code>snake_case</code> (e.g., <code>emit_instruction</code>)</li> <li>Constants: <code>SCREAMING_SNAKE_CASE</code> (e.g., <code>MAX_STACK_DEPTH</code>)</li> <li>Modules: <code>snake_case</code> (e.g., <code>codegen</code>)</li> </ul>"},{"location":"contributing/style-guide/#error-handling","title":"Error Handling","text":"<ul> <li>Use <code>Result</code> and <code>Option</code> types instead of <code>panic!</code>.</li> <li>Use the <code>thiserror</code> or <code>anyhow</code> crates for descriptive error messages in the compiler.</li> </ul>"},{"location":"contributing/style-guide/#documentation-style","title":"Documentation Style","text":"<p>Our documentation aims to be \"Linux Kernel meets Stripe\" \u2013 technical yet extremely accessible.</p>"},{"location":"contributing/style-guide/#markdown-rules","title":"Markdown Rules","text":"<ul> <li>Headers: Use Title Case for H1 and H2.</li> <li>Code Blocks: Always specify the language (e.g., <code>```rust</code>).</li> <li>Admonitions: Use Material for MkDocs admonitions (e.g., <code>!!! info</code>) to highlight important notes.</li> </ul>"},{"location":"contributing/style-guide/#visuals","title":"Visuals","text":"<ul> <li>Use Mermaid.js for all diagrams.</li> <li>Keep diagrams simple and focused on one concept.</li> </ul>"},{"location":"contributing/style-guide/#commit-messages","title":"Commit Messages","text":"<p>We follow Conventional Commits: - <code>feat: ...</code> for new features. - <code>fix: ...</code> for bug fixes. - <code>docs: ...</code> for documentation changes. - <code>refactor: ...</code> for code changes that neither fix a bug nor add a feature.</p> <p>Found an inconsistency? Submit a PR to update this guide!</p>"},{"location":"ebpf/helpers/","title":"eBPF Helpers","text":"<p>eBPF programs interact with the kernel through a stable set of \"helper functions\" provided by the Linux kernel.</p>"},{"location":"ebpf/helpers/#how-solnix-wraps-helpers","title":"How Solnix Wraps Helpers","text":"<p>Solnix provides a clean syntax (<code>ctx.method</code>) which the compiler automatically maps to the corresponding eBPF helper call with the correct arguments.</p>"},{"location":"ebpf/helpers/#mapping-table","title":"Mapping Table","text":"Solnix Method Linux Kernel Helper Purpose <code>ctx.get_pid_tgid()</code> <code>bpf_get_current_pid_tgid</code> Get 64-bit PID and TGID <code>ctx.get_uid_gid()</code> <code>bpf_get_current_uid_gid</code> Get current UID and GID <code>ctx.get_current_comm()</code> <code>bpf_get_current_comm</code> Copy process name to buffer <code>ctx.get_ktime_ns()</code> <code>bpf_ktime_get_ns</code> Get uptime in nanoseconds <code>ctx.probe_read_user_str()</code> <code>bpf_probe_read_user_str</code> Read string from userspace <code>ctx.probe_read_kernel_str()</code> <code>bpf_probe_read_kernel_str</code> Read string from kernel <code>map.lookup(key)</code> <code>bpf_map_lookup_elem</code> Retrieve pointer from map <code>map.update(key, val)</code> <code>bpf_map_update_elem</code> Update or insert map element"},{"location":"ebpf/helpers/#implementation","title":"Implementation","text":"<p>These helpers are essentially system calls for eBPF. Solnix handles the register allocation and calling conventions required by the BPF calling standard (R1-R5 for arguments, R0 for return value).</p>"},{"location":"ebpf/limitations/","title":"eBPF Limitations","text":"<p>While eBPF is powerful, it operates under strict constraints to guarantee kernel safety and performance.</p>"},{"location":"ebpf/limitations/#resource-limits","title":"Resource Limits","text":"<ul> <li>Stack size: Strictly limited to 512 bytes.</li> <li>Dynamic Allocation: There is no <code>malloc</code> or <code>free</code>. All memory must be pre-allocated via maps or the stack.</li> <li>Recursion: Recursion is strictly forbidden to prevent stack overflow.</li> </ul>"},{"location":"ebpf/limitations/#execution-limits","title":"Execution Limits","text":"<ul> <li>Loops: Loops must be bounded and detectable by the verifier at load time. Solnix encourages unrolled or simple bounded iterations.</li> <li>Instruction Count: There is a limit on the number of non-branch instructions in a single program path (historically 4k, modern kernels allow up to 1M).</li> <li>Execution Time: Programs must run to completion quickly to avoid stalling the kernel.</li> </ul>"},{"location":"ebpf/limitations/#contextual-restrictions","title":"Contextual Restrictions","text":"<ul> <li>Not all helpers are available to all program types (e.g., packet mangling is restricted to XDP and TC ingress).</li> <li>Certain program types (like Kprobes) cannot access network packet data directly without going through specific memory probes.</li> </ul>"},{"location":"ebpf/limitations/#floating-point","title":"Floating Point","text":"<ul> <li>eBPF does not support floating-point arithmetic. Use integer arithmetic and scaling if decimal values are needed.</li> </ul>"},{"location":"ebpf/maps/","title":"eBPF Maps","text":"<p>Maps are the primary mechanism for eBPF programs to maintain persistent state and communicate with other programs or userspace.</p>"},{"location":"ebpf/maps/#supported-map-types","title":"Supported Map Types","text":"<p>Solnix supports the most common eBPF map structures: - .hash: Key-value store (associative array). - .array: Fixed-size index-based storage. - .lru_hash: Hash map that automatically evicted least recently used items. - .ringbuf: High-performance buffer for streaming data to userspace. - .prog_array: Stores file descriptors for other eBPF programs (used for tail calls).</p>"},{"location":"ebpf/maps/#lifetime","title":"Lifetime","text":"<ul> <li>Maps exist independent of the eBPF program's execution.</li> <li>They are created when the program object is loaded into the kernel.</li> <li>They persist as long as a program or userspace process holds a reference to them.</li> </ul>"},{"location":"ebpf/maps/#memory-limits","title":"Memory Limits","text":"<ul> <li>Map memory is allocated from kernel space (locked memory).</li> <li>The <code>max</code> field in Solnix defines the limit. Exceeding this limit will cause insertions to fail.</li> <li>For <code>ringbuf</code>, the size must be a multiple of the kernel page size (usually 4KB).</li> </ul>"},{"location":"ebpf/memory-model/","title":"eBPF Memory Model","text":"<p>Understanding the different memory regions available to eBPF programs is key to writing efficient and verifiable code.</p>"},{"location":"ebpf/memory-model/#stack-memory","title":"Stack Memory","text":"<ul> <li>Local variables declared with <code>reg</code> or <code>imm</code> occupy registers or a small portion of the stack.</li> <li>Size: 512 bytes maximum.</li> <li>Usage: Small counters, temporary constants, and pointers.</li> </ul>"},{"location":"ebpf/memory-model/#map-memory","title":"Map Memory","text":"<ul> <li>Reserved via the <code>map</code> keyword.</li> <li>Resides outside the program stack.</li> <li>Accessible via the <code>heap</code> keyword in Solnix.</li> <li>Usage: Persistent state, large tables, and cross-invocation data.</li> </ul>"},{"location":"ebpf/memory-model/#ring-buffer-memory","title":"Ring Buffer Memory","text":"<ul> <li>Specialized memory for passing events to userspace.</li> <li>Programs \"reserve\" a chunk, fill it, and \"submit\" it.</li> <li>Shared with userspace via a memory-mapped buffer.</li> </ul>"},{"location":"ebpf/memory-model/#kernel-vs-user-memory","title":"Kernel vs. User Memory","text":"<ul> <li>eBPF programs run in kernel space. They cannot directly dereference userspace pointers.</li> <li>To read from userspace (e.g., in a syscall tracepoint), you must use \"probe read\" helpers: <code>ctx.probe_read_user_str</code>.</li> </ul>"},{"location":"ebpf/memory-model/#pointer-safety","title":"Pointer Safety","text":"<p>All memory access must be bounded and verified. Solnix enforces this through its <code>heap</code> pointer rules and the <code>if guard</code> safety block.</p>"},{"location":"ebpf/overview/","title":"eBPF Overview - Understanding the Backend","text":"<ul> <li>ebpf</li> <li>compiler</li> <li>rust</li> </ul>"},{"location":"ebpf/overview/#ebpf-overview","title":"eBPF Overview","text":""},{"location":"ebpf/overview/#what-is-ebpf","title":"What is eBPF","text":"<p>eBPF (Extended Berkeley Packet Filter) is a revolutionary technology that allows running sandboxed programs within the Linux kernel without changing kernel source code or loading kernel modules. It provides a safe way to extend kernel functionality for networking, observability, and security.</p>"},{"location":"ebpf/overview/#execution-model","title":"Execution Model","text":"<p>eBPF programs are event-driven. They are attached to specific \"hook points\" in the kernel (such as packet arrival, system calls, or function entries). When the hook point is reached, the eBPF program executes. - Hooks: Entry points like XDP, TC, or Kprobes. - Verification: Programs are strictly checked by the kernel verifier before loading to ensure they won't crash the system. - JIT Compilation: Bytecode is JIT-compiled into native CPU instructions for near-native performance.</p>"},{"location":"ebpf/overview/#how-solnix-targets-ebpf","title":"How Solnix Targets eBPF","text":"<p>Solnix provides a high-level domain-specific language that abstracts away the complexities of C-based eBPF development. 1. Source: You write Solnix (.snx) code. 2. Compiler: <code>solnixc</code> parses and lowers the code into an Intermediate Representation (IR). 3. Backend: The compiler generates eBPF-compatible C code or bytecode. 4. Loading: The resulting object file is loaded into the kernel using standard tools like <code>iproute2</code> or <code>libbpf</code>.</p>"},{"location":"ebpf/program-types/","title":"eBPF Program Types","text":"<p>Solnix supports various eBPF program types, each tailored for specific kernel hook points.</p>"},{"location":"ebpf/program-types/#xdp-express-data-path","title":"XDP (eXpress Data Path)","text":"<ul> <li>When it runs: At the earliest point in the network driver, before the kernel networking stack processes the packet.</li> <li>Context type: <code>struct xdp_md</code></li> <li>Typical usage: High-speed packet filtering, DDoS protection, and load balancing.</li> </ul>"},{"location":"ebpf/program-types/#tc-traffic-control","title":"TC (Traffic Control)","text":"<ul> <li>When it runs: During the ingress or egress phases of the Linux networking stack.</li> <li>Context type: <code>struct __sk_buff</code></li> <li>Typical usage: Traffic shaping, policing, and advanced packet mangling.</li> </ul>"},{"location":"ebpf/program-types/#kprobe-kretprobe","title":"Kprobe &amp; Kretprobe","text":"<ul> <li>When it runs: At the entry (kprobe) or exit (kretprobe) of almost any kernel function.</li> <li>Context type: <code>struct pt_regs</code></li> <li>Typical usage: Dynamic performance tracing and kernel debugging.</li> </ul>"},{"location":"ebpf/program-types/#tracepoint","title":"Tracepoint","text":"<ul> <li>When it runs: At pre-defined static tracepoints built into the kernel.</li> <li>Context type: Specific to the tracepoint.</li> <li>Typical usage: Stable observability and event logging.</li> </ul>"},{"location":"ebpf/program-types/#raw-tracepoint","title":"Raw Tracepoint","text":"<ul> <li>When it runs: Similar to tracepoints but with direct access to raw arguments for higher performance.</li> <li>Context type: <code>struct bpf_raw_tracepoint_args</code></li> <li>Typical usage: Low-overhead monitoring.</li> </ul>"},{"location":"ebpf/verifier/","title":"eBPF Verifier","text":"<p>The verifier is a safety gatekeeper that ensures eBPF programs cannot compromise kernel stability or security.</p>"},{"location":"ebpf/verifier/#common-rejection-reasons","title":"Common Rejection Reasons","text":"<p>Programs are rejected if they: - Attempt to access out-of-bounds memory. - Contain infinite loops or reach the instruction limit. - Access uninitialized registers. - Use pointers without null-checks (see Solnix <code>if guard</code>).</p>"},{"location":"ebpf/verifier/#stack-limit","title":"Stack Limit","text":"<ul> <li>Constraint: Each eBPF program is limited to 512 bytes of stack space.</li> <li>Tip: Use <code>reg</code> for small counters and <code>heap</code> (via maps) for larger data structures or state.</li> </ul>"},{"location":"ebpf/verifier/#pointer-safety","title":"Pointer Safety","text":"<ul> <li>Pointers must be validated before derefencing.</li> <li>The verifier tracks the state of every register. If a register contains a pointer that might be NULL (e.g., from a map lookup), any access to it without a previous zero-check will fail verification.</li> </ul>"},{"location":"ebpf/verifier/#loops","title":"Loops","text":"<ul> <li>Historically, eBPF did not support loops. </li> <li>Modern kernels allow bounded loops, but Solnix current focus is on unrolled execution or simple bounded patterns to maintain wide compatibility.</li> </ul>"},{"location":"examples/execve-filename-monitor/","title":"Execve Filename Monitor","text":"<p>Monitor every process execution and capture the filename being executed via ring buffers.</p>"},{"location":"examples/execve-filename-monitor/#source","title":"Source","text":"<pre><code>map events {\n    type: .ringbuf;\n    max: 16777216; // 1 &lt;&lt; 24\n}\n\nevent exec_event {\n    pid: u32;\n    filename: bytes[256];\n}\n\nunit trace_exec_filename {\n    section: \"tracepoint/syscalls/sys_enter_execve\";\n    license: \"GPL\";\n\n    reg pid_tgid = ctx.get_pid_tgid();\n    reg pid = pid_tgid;\n\n    // In sys_enter_execve, filename pointer is at offset 16\n    reg filename_ptr = ctx.load_u64(16);\n\n    heap evt = events.reserve(exec_event);\n\n    if guard(evt) {\n        evt.pid = pid;\n        ctx.probe_read_user_str(evt.filename, 256, filename_ptr);\n        events.submit(evt);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/execve-filename-monitor/#demonstrates","title":"Demonstrates","text":"<ul> <li><code>tracepoint</code> hooks</li> <li><code>ctx</code> helpers (<code>get_pid_tgid</code>, <code>load_u64</code>)</li> <li><code>ringbuf</code> maps for high-performance streaming</li> <li><code>event</code> structures</li> <li><code>probe_read_user_str</code> for safe memory access</li> </ul>"},{"location":"examples/process-exit-counter/","title":"Process Exit Counter","text":"<p>Count the number of times each process (by PID) exits using a hash map.</p>"},{"location":"examples/process-exit-counter/#source","title":"Source","text":"<pre><code>map exit_counter {\n    type: .hash;\n    key: u32;      \n    value: u64;    \n    max: 8192;\n}\n\nunit trace_exit_monitor {\n    section: \"tracepoint/sched/sched_process_exit\";\n    license: \"GPL\";\n\n    // PID is at offset 16 in sched_process_exit\n    reg pid = ctx.load_u32(16);\n\n    heap count = exit_counter.lookup(pid);\n\n    if guard(count) {\n        *count += 1;\n    } else {\n        exit_counter.update(pid, 1);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/process-exit-counter/#demonstrates","title":"Demonstrates","text":"<ul> <li><code>tracepoint</code> hooks</li> <li><code>hash</code> maps for persistent state</li> <li><code>lookup</code> and <code>update</code> map methods</li> <li><code>heap</code> pointer safety and <code>guard</code> blocks</li> </ul>"},{"location":"examples/process-fork-monitor/","title":"Process Fork Monitor","text":"<p>Track how many times parent processes fork new children.</p>"},{"location":"examples/process-fork-monitor/#source","title":"Source","text":"<pre><code>map fork_counter {\n    type: .hash;\n    key: u32;      \n    value: u64;    \n    max: 8192;\n}\n\nunit trace_fork_monitor {\n    section: \"tracepoint/sched/sched_process_fork\";\n    license: \"GPL\";\n\n    // Parent PID is at offset 16 in sched_process_fork\n    reg parent_pid = ctx.load_u32(16);\n\n    heap count = fork_counter.lookup(parent_pid);\n\n    if guard(count) {\n        *count += 1;\n    } else {\n        fork_counter.update(parent_pid, 1);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/process-fork-monitor/#demonstrates","title":"Demonstrates","text":"<ul> <li><code>tracepoint</code> hook for scheduler events</li> <li><code>hash</code> map usage</li> <li>Atomic-like updates via <code>*count += 1</code> in guarded blocks</li> </ul>"},{"location":"examples/sys-openat-counter/","title":"Sys Openat Counter","text":"<p>Count how many times each process attempts to open a file.</p>"},{"location":"examples/sys-openat-counter/#source","title":"Source","text":"<pre><code>map open_counter {\n    type: .hash;\n    key: u32;\n    value: u64;\n    max: 10240;\n}\n\nunit trace_openat {\n    section: \"tracepoint/syscalls/sys_enter_openat\";\n    license: \"GPL\";\n\n    reg pid_tgid = ctx.get_pid_tgid();\n    reg pid = pid_tgid;\n\n    heap count_ptr = open_counter.lookup(pid);\n\n    if guard(count_ptr) {\n        *count_ptr += 1;\n    } else {\n        open_counter.update(pid, 1);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/sys-openat-counter/#demonstrates","title":"Demonstrates","text":"<ul> <li>Syscall entry <code>tracepoint</code></li> <li>Using <code>ctx.get_pid_tgid()</code> for process identification</li> <li>Conditional map updates</li> </ul>"},{"location":"examples/xdp-drop-all/","title":"XDP Packet Dropper","text":"<p>A simple XDP program that counts processed packets and drops all traffic.</p>"},{"location":"examples/xdp-drop-all/#source","title":"Source","text":"<pre><code>map drop_stats {\n    type: .array;\n    key: u32;\n    value: u64;\n    max: 1;\n}\n\nunit xdp_drop_all {\n    section: \"xdp\";\n    license: \"GPL\";\n\n    reg key = 0;\n    heap count = drop_stats.lookup(key);\n\n    if guard(count) {\n        *count += 1;\n    }\n\n    // Return 2 to DROP the packet\n    return 2;\n}\n</code></pre>"},{"location":"examples/xdp-drop-all/#demonstrates","title":"Demonstrates","text":"<ul> <li><code>xdp</code> program type for high-performance networking</li> <li><code>array</code> maps for global counters</li> <li>Returning action codes (DROP) to the kernel</li> </ul>"},{"location":"getting-started/installation/","title":"Installing Solnix - Setup Guide","text":"<ul> <li>ebpf</li> <li>compiler</li> <li>rust</li> </ul>"},{"location":"getting-started/installation/#installation","title":"Installation","text":"<p>This guide explains how to install the Solnix compiler and CLI on Linux</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>Before installing Solnix, make sure you have:</p> <ul> <li>Linux kernel 5.10+ (required for eBPF support)</li> <li>clang (for C backend compilation)</li> <li>Rust (for building from source)</li> <li>libbpf</li> </ul>"},{"location":"getting-started/installation/#quick-install-prebuilt-binary","title":"Quick Install (Prebuilt Binary)","text":"<p>Download the latest version:</p> <p></p> <p>   Download for Linux x86_64 </p>"},{"location":"getting-started/installation/#verify","title":"Verify","text":"<pre><code>solnixc --version\n</code></pre>"},{"location":"getting-started/installation/#build-from-source","title":"Build From Source","text":"<p><pre><code>git clone https://github.com/solnix-lang/solnix-compiler.git\n\ncd solnix-compiler\n\ncargo build --release\n</code></pre> Note: After successful build, the binary <code>solnixc</code> will be generated in <code>target/release/</code></p>"},{"location":"getting-started/installation/#post-install-setup","title":"Post-Install Setup","text":""},{"location":"getting-started/installation/#kernel-headers","title":"Kernel Headers","text":"<p>Ensure kernel headers are installed for your distribution:</p> <pre><code># Ubuntu/Debian\nsudo apt install linux-headers-$(uname -r)\n\n# Fedora/RHEL\nsudo dnf install kernel-headers kernel-devel\n\n# Arch\nsudo pacman -S linux-headers\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>This guide walks you through compiling and running your first Solnix eBPF programs.</p> <p>Solnix programs are written in <code>.snx</code> files and compiled using:</p> <p>solnixc compile program.snx program.o</p> <p>After compilation, build artifacts are generated in:</p> <p>.snx/build/</p>"},{"location":"getting-started/quickstart/#1-execve-filename-monitor","title":"1 Execve Filename Monitor","text":"<p>This example captures filenames passed to <code>execve()</code> using a ring buffer.</p> <p>File: <code>execve_filename_monitor.snx</code></p> <pre><code>map events {  \n    type: .ringbuf,  \n    max: 1 &lt;&lt; 24  \n}  \n\nevent exec_event {  \n    pid: u32,  \n    filename: bytes[256]  \n}  \n\nunit trace_exec_filename {  \n    section \"tracepoint/syscalls/sys_enter_execve\"  \n    license \"GPL\"  \n\n    reg pid_tgid = ctx.get_pid_tgid()  \n    reg pid = pid_tgid  \n\n    reg filename_ptr = ctx.load_u64(16)  \n\n    heap evt = events.reserve(exec_event)  \n\n    if guard(evt) {  \n        evt.pid = pid  \n        ctx.probe_read_user_str(evt.filename, 256, filename_ptr)  \n        events.submit(evt)  \n    }  \n\n    return 0  \n}\n</code></pre>"},{"location":"getting-started/quickstart/#compile","title":"Compile","text":"<pre><code>solnixc compile execve_filename_monitor.snx execve_filename_monitor.o\n</code></pre>"},{"location":"getting-started/quickstart/#2-process-exit-counter","title":"2 Process Exit Counter","text":"<p>Counts how many times each PID exits using a hash map.</p> <p>File: <code>sched_process_exit_counter.snx</code></p> <pre><code>map exit_counter {  \n    type: .hash;  \n    key: u32;        \n    value: u64;      \n    max: 8192;  \n}  \n\nunit trace_exit_monitor {  \n    section: \"tracepoint/sched/sched_process_exit\";  \n    license: \"GPL\";  \n\n    reg pid = ctx.load_u32(16);  \n\n    heap count = exit_counter.lookup(pid);  \n\n    if guard(count) {  \n        *count += 1;  \n    } else {  \n        exit_counter.update(pid, 1);  \n    }  \n\n    return 0;  \n}\n</code></pre>"},{"location":"getting-started/quickstart/#compile_1","title":"Compile","text":"<pre><code>solnixc compile sched_process_exit_counter.snx sched_process_exit_counter.o\n</code></pre>"},{"location":"getting-started/quickstart/#3-process-fork-counter","title":"3 Process Fork Counter","text":"<p>Tracks how many forks are triggered per parent PID.</p> <p>File: <code>sched_process_fork_monitor.snx</code> <pre><code>map fork_counter {  \n    type: .hash;  \n    key: u32;        \n    value: u64;      \n    max: 8192;  \n}  \n\nunit trace_fork_monitor {  \n    section: \"tracepoint/sched/sched_process_fork\";  \n    license: \"GPL\";  \n\n    reg parent_pid = ctx.load_u32(16);  \n\n    heap count = fork_counter.lookup(parent_pid);  \n\n    if guard(count) {  \n        *count += 1;  \n    } else {  \n        fork_counter.update(parent_pid, 1);  \n    }  \n\n    return 0;  \n}\n</code></pre></p>"},{"location":"getting-started/quickstart/#compile_2","title":"Compile","text":"<pre><code>solnixc compile sched_process_fork_monitor.snx sched_process_fork_monitor.o\n</code></pre>"},{"location":"getting-started/quickstart/#4-execve-counter-hash-map-example","title":"4 Execve Counter (Hash Map Example)","text":"<p>Counts <code>execve</code> calls per PID.</p> <p>File: <code>sys_enter_execve.snx</code> <pre><code>map execve_counter {  \n    type: .hash;  \n    key: u32;  \n    value: u64;  \n    max: 10240;  \n}  \n\nunit trace_execve {  \n    section: \"tracepoint/syscalls/sys_enter_execve\";  \n    license: \"GPL\";  \n\n    reg pid_tgid = get_pid_tgid();  \n    reg pid = pid_tgid;  \n\n    heap count_ptr = execve_counter.lookup(pid);  \n\n    if guard(count_ptr) {  \n        *count_ptr += 1;  \n    } else {  \n        execve_counter.update(pid, 1);  \n    }  \n\n    return 0;  \n}\n</code></pre></p>"},{"location":"getting-started/quickstart/#compile_3","title":"Compile","text":"<pre><code>solnixc compile sys_enter_execve.snx sys_enter_execve.o\n</code></pre>"},{"location":"getting-started/quickstart/#build-output","title":"Build Output","text":"<p>After compilation:</p> <p>.snx/  \u2514\u2500\u2500 build/       \u251c\u2500\u2500 .c       \u251c\u2500\u2500 .o       \u2514\u2500\u2500 vmlinux.h <ul> <li> <p><code>.c</code> \u2192 Generated backend C code</p> </li> <li> <p><code>.o</code> \u2192 eBPF ELF object</p> </li> <li> <p><code>vmlinux.h</code> \u2192 Kernel BTF header</p> </li> </ul>"},{"location":"getting-started/quickstart/#loading-the-program-example","title":"Loading the Program (Example)","text":"<p>After compilation:</p> <p>sudo bpftool prog load execve_filename_monitor.o /sys/fs/bpf/execmon</p> <p>Attach to tracepoint:</p> <p>sudo bpftool prog attach pinned /sys/fs/bpf/execmon tracepoint syscalls:sys_enter_execve</p>"},{"location":"getting-started/toolchain/","title":"Toolchain","text":"<p>The Solnix toolchain is responsible for compiling <code>.snx</code> source files into eBPF-compatible object files using a C backend generation model.</p> <p>Currently, the toolchain consists of a single CLI compiler:</p> <p>solnixc</p> <p>The compiler is implemented in Rust and generates C code, which is then compiled using Clang into an eBPF object file.</p>"},{"location":"getting-started/toolchain/#compiler-cli","title":"Compiler CLI","text":"<p>The main compiler binary:</p> <p>solnixc</p> <p>Check version:</p> <pre><code>solnixc --version\n</code></pre>"},{"location":"getting-started/toolchain/#basic-compilation","title":"Basic Compilation","text":"<p>Compile a Solnix program:</p> <pre><code>solnixc compile test.snx test.o\n</code></pre>"},{"location":"getting-started/toolchain/#what-happens-internally","title":"What Happens Internally","text":"<p>When you run the command above:</p> <ol> <li> <p><code>test.snx</code> is parsed and validated.</p> </li> <li> <p>C backend code is generated.</p> </li> <li> <p>Clang compiles generated C code into eBPF bytecode.</p> </li> <li> <p>Required kernel headers (vmlinux.h) are included.</p> </li> <li> <p>Final ELF object file is produced.</p> </li> </ol>"},{"location":"getting-started/toolchain/#build-output-structure","title":"Build Output Structure","text":"<p>After compilation, Solnix generates a build directory:</p> <p>.snx/  \u2514\u2500\u2500 build/       \u251c\u2500\u2500 test.c       \u251c\u2500\u2500 test.o       \u2514\u2500\u2500 vmlinux.h</p>"},{"location":"getting-started/toolchain/#generated-files","title":"Generated Files","text":"File Description <code>test.c</code> Generated C backend code <code>test.o</code> Compiled eBPF ELF object <code>vmlinux.h</code> Auto-generated BTF header"},{"location":"getting-started/toolchain/#automatic-vmlinuxh-generation","title":"Automatic vmlinux.h Generation","text":"<p>If not present, Solnix generates:</p> <p>.snx/build/vmlinux.h</p> <p>Using kernel BTF data (via bpftool or system BTF path).</p> <p>This header enables:</p> <ul> <li> <p>CO-RE (Compile Once \u2013 Run Everywhere)</p> </li> <li> <p>Kernel struct compatibility</p> </li> <li> <p>BPF Type Format resolution</p> </li> </ul>"},{"location":"getting-started/toolchain/#default-build-directory","title":"Default Build Directory","text":"<p>Solnix always creates:</p> <p>.snx/</p> <p>This directory contains:</p> <ul> <li> <p>Intermediate files</p> </li> <li> <p>Build artifacts</p> </li> <li> <p>Kernel headers</p> </li> <li> <p>Cache (future feature)</p> </li> </ul> <p>It is recommended to add <code>.snx/</code> to <code>.gitignore</code>.</p>"},{"location":"getting-started/toolchain/#architecture-support","title":"Architecture Support","text":"<p>Currently supported:</p> <p>x86_64</p> <p>Planned:</p> <p>arm64</p>"},{"location":"getting-started/toolchain/#future-toolchain-expansion","title":"Future Toolchain Expansion","text":"<p>Planned additions:</p> <ul> <li> <p><code>solnixc build</code> (project mode)</p> </li> <li> <p><code>solnixc run</code></p> </li> <li> <p><code>solnixc check</code></p> </li> <li> <p><code>solnixc fmt</code></p> </li> <li> <p>Package manager integration</p> </li> <li> <p>Incremental compilation</p> </li> <li> <p>Optimized IR passes</p> </li> </ul>"},{"location":"getting-started/toolchain/#summary","title":"Summary","text":"<p>Current toolchain includes:</p> <p>solnixc  \u2192  C backend  \u2192  Clang  \u2192  eBPF ELF object</p> <p>Output artifacts:</p> <p>.snx/build/</p> <p>Solnix keeps the toolchain minimal, explicit, and transparent.</p>"},{"location":"language/control_flow/","title":"control flow","text":"<p>Branching and termination constructs for eBPF program logic.</p>"},{"location":"language/control_flow/#syntax","title":"Syntax","text":"<pre><code>// Pointer validation\nif guard(heap_ptr) {\n    // verified safe block\n} else {\n    // optional fallback block\n}\n\n// Program termination\nreturn expression;\n</code></pre>"},{"location":"language/control_flow/#description","title":"Description","text":"<ul> <li>if guard: The primary conditional construct. It is used to validate <code>heap</code> pointers (map lookup results). </li> <li>else: An optional block executed if the <code>guard</code> condition fails (pointer is null).</li> <li>return: Terminates the program execution and returns a status code to the kernel.</li> <li>Return Values:</li> <li>In <code>xdp</code> programs, common values are <code>1</code> (PASS) or <code>2</code> (DROP).</li> <li>In <code>kprobe</code> and other tracing types, the return value is usually <code>0</code>.</li> </ul>"},{"location":"language/control_flow/#example","title":"Example","text":"<pre><code>heap val = my_map.lookup(key);\n\nif guard(val) {\n    *val += 1;\n    return 1;\n} else {\n    return 2;\n}\n</code></pre>"},{"location":"language/ctx_helpers/","title":"ctx helpers","text":"<p>Built-in methods for interacting with the eBPF program context and kernel state.</p>"},{"location":"language/ctx_helpers/#syntax","title":"Syntax","text":"<pre><code>ctx.method_name(arguments)\n</code></pre>"},{"location":"language/ctx_helpers/#description","title":"Description","text":"<ul> <li>Provides access to packet data, process information, and kernel utilities.</li> <li><code>load_u8/u16/u32/u64</code>: Loads data from context at an offset (e.g., packet data).</li> <li><code>get_pid_tgid()</code>: Returns current PID (high 32 bits) and TGID (low 32 bits).</li> <li><code>get_uid_gid()</code>: Returns current UID and GID.</li> <li><code>get_current_comm()</code>: Returns the current process name.</li> <li><code>get_ktime_ns()</code>: Returns the current kernel time in nanoseconds.</li> <li><code>probe_read_user_str(dest, size, src)</code>: Safely reads a string from userspace memory.</li> <li><code>probe_read_kernel_str(dest, size, src)</code>: Safely reads a string from kernel memory.</li> <li>Availability of specific helpers depends on the <code>unit</code> section type (XDP, TC, Kprobe, etc.).</li> </ul>"},{"location":"language/ctx_helpers/#example","title":"Example","text":"<pre><code>reg src_port = ctx.load_u16(34);\nreg pid = ctx.get_pid_tgid() &gt;&gt; 32;\nreg time = ctx.get_ktime_ns();\n</code></pre>"},{"location":"language/events/","title":"event","text":"<p>Custom structure definitions used for transmitting data to userspace, typically via ring buffers.</p>"},{"location":"language/events/#syntax","title":"Syntax","text":"<pre><code>event Name {\n    field_name: Type;\n    field_name: Type[Size];\n}\n</code></pre>"},{"location":"language/events/#description","title":"Description","text":"<ul> <li>Defines the layout of data sent from the kernel to userspace.</li> <li>Fields support primitive types (<code>u32</code>, <code>u64</code>, etc.).</li> <li><code>bytes[N]</code>: Defines a raw byte buffer of size <code>N</code>.</li> <li><code>Type[N]</code>: Defines a fixed-size array of the specified type.</li> <li>Access: Event fields can be accessed or assigned using dot notation: <code>ptr.field_name = value</code>.</li> </ul>"},{"location":"language/events/#example","title":"Example","text":"<pre><code>event PacketInfo {\n    src_ip: u32;\n    payload_size: u32;\n    signature: bytes[16];\n}\n\n// Inside a unit with a reserved ringbuf pointer:\nheap evt = sample_rb.reserve(PacketInfo);\nif guard(evt) {\n    evt.src_ip = ctx.load_u32(26);\n    sample_rb.submit(evt);\n}\n</code></pre>"},{"location":"language/heap/","title":"heap","text":"<p>Variable declarations for pointers that reference memory in eBPF maps.</p>"},{"location":"language/heap/#syntax","title":"Syntax","text":"<pre><code>heap name = map_name.lookup(key);\n</code></pre>"},{"location":"language/heap/#description","title":"Description","text":"<ul> <li>Stores a pointer to a value in a map.</li> <li>Memory is managed by the eBPF map system.</li> <li>Safety: A <code>heap</code> pointer must be verified via <code>if guard()</code> before it can be dereferenced.</li> <li>Supports indirect modification of map values via the dereference operator <code>*</code>.</li> </ul>"},{"location":"language/heap/#example","title":"Example","text":"<pre><code>heap val = my_map.lookup(key);\nif guard(val) {\n    *val += 1;\n}\n</code></pre>"},{"location":"language/imm/","title":"imm","text":"<p>Declarations for immediate values and constants.</p>"},{"location":"language/imm/#syntax","title":"Syntax","text":"<pre><code>imm name = constant_expression;\n</code></pre>"},{"location":"language/imm/#description","title":"Description","text":"<ul> <li>Defines a named constant or immediate value.</li> <li>Expressions are evaluated at compile-time.</li> <li>Used for flags, offsets, or configuration values that do not change during execution.</li> </ul>"},{"location":"language/imm/#example","title":"Example","text":"<pre><code>imm ETH_P_IP = 0x0800;\nimm MAX_RETRIES = 5;\n</code></pre>"},{"location":"language/maps/","title":"map","text":"<p>Global data structures used for persistent state and sharing data between kernel and userspace.</p>"},{"location":"language/maps/#syntax","title":"Syntax","text":"<pre><code>map Name {\n    type: .map_kind;\n    key: KeyType;\n    value: ValueType;\n    max: Entries;\n}\n</code></pre>"},{"location":"language/maps/#description","title":"Description","text":"<ul> <li><code>type</code>: The eBPF map type (prefixed with <code>.</code>). Supported: <code>.hash</code>, <code>.array</code>, <code>.ringbuf</code>, <code>.lru_hash</code>, <code>.prog_array</code>, <code>.perf_event_array</code>.</li> <li><code>key</code>: The primitive data type for the lookup key.</li> <li><code>value</code>: The data type for the stored value.</li> <li><code>max</code>: Defines the maximum number of entries or buffer size.</li> </ul>"},{"location":"language/maps/#methods","title":"Methods","text":"<ul> <li><code>lookup(key)</code>: Returns a <code>heap</code> pointer to the value associated with the key.</li> <li><code>update(key, value)</code>: Updates or inserts a value for the specified key.</li> <li><code>reserve(EventName)</code>: Reserves space in a <code>ringbuf</code> for an event of the given type.</li> <li><code>submit(ptr)</code>: Commits a reserved <code>ringbuf</code> entry for transmission.</li> </ul>"},{"location":"language/maps/#example","title":"Example","text":"<pre><code>map counters {\n    type: .hash;\n    key: u32;\n    value: u64;\n    max: 1024;\n}\n\n// In unit:\nreg key = 1;\ncounters.update(key, 100);\nheap val = counters.lookup(key);\n</code></pre>"},{"location":"language/memory_rules/","title":"memory rules","text":"<p>Rules and constraints for safe memory access in eBPF programs.</p>"},{"location":"language/memory_rules/#syntax","title":"Syntax","text":"<pre><code>if guard(ptr) {\n    *ptr = ...;\n}\n</code></pre>"},{"location":"language/memory_rules/#description","title":"Description","text":"<ul> <li>Guard Rule: All <code>heap</code> pointers obtained from map lookups must be checked for <code>null</code> using the <code>if guard(ptr)</code> construct before access.</li> <li>Dereference: Use the <code>*</code> operator to access the underlying value of a <code>heap</code> pointer.</li> <li>Stack Constraints: Local <code>reg</code> variables are stored in registers or on the stack; stack size is limited (typically 512 bytes).</li> <li>Immutability: <code>imm</code> values are evaluated at compile-time and cannot be modified at runtime.</li> </ul>"},{"location":"language/memory_rules/#example","title":"Example","text":"<pre><code>heap ptr = my_map.lookup(key);\n\nif guard(ptr) {\n    // Verified safe to access\n    *ptr = 100;\n}\n</code></pre>"},{"location":"language/reg/","title":"reg","text":"<p>Local variable declarations that map directly to CPU registers.</p>"},{"location":"language/reg/#syntax","title":"Syntax","text":"<pre><code>reg name = expression;\n</code></pre>"},{"location":"language/reg/#description","title":"Description","text":"<ul> <li>Declares a register-backed variable.</li> <li>Used for arithmetic, logic, and storing results from context helpers.</li> <li>Scope is limited to the containing <code>unit</code>.</li> <li>Values can be modified using assignment operators (<code>=</code>, <code>+=</code>, etc.).</li> </ul>"},{"location":"language/reg/#example","title":"Example","text":"<pre><code>reg id = ctx.get_pid_tgid();\nreg count = 10;\ncount += 1;\n</code></pre>"},{"location":"language/types/","title":"types","text":"<p>Primitive and complex data types supported by the Solnix language.</p>"},{"location":"language/types/#syntax","title":"Syntax","text":"<pre><code>// Primitives\nu32, u64\ni32, i64\n\n// Complex\nbytes[N]\nType[N]\n</code></pre>"},{"location":"language/types/#description","title":"Description","text":"<ul> <li>Primitives: Sized integers (unsigned and signed).</li> <li>bytes[N]: A raw buffer of <code>N</code> bytes.</li> <li>Type[N]: A fixed-size array containing <code>N</code> elements of a specific type.</li> <li>Used in <code>map</code> definitions, <code>event</code> fields, and variable declarations.</li> </ul>"},{"location":"language/types/#example","title":"Example","text":"<pre><code>event Log {\n    msg: bytes[64];\n    counts: u32[4];\n    timestamp: u64;\n}\n</code></pre>"},{"location":"language/units/","title":"unit","text":"<p>The primary container for eBPF program logic and metadata.</p>"},{"location":"language/units/#syntax","title":"Syntax","text":"<pre><code>unit Name {\n    section: \"type\";\n    license: \"License\";\n\n    // code body\n}\n</code></pre>"},{"location":"language/units/#description","title":"Description","text":"<ul> <li>Defines an entry point for an eBPF program.</li> <li><code>section</code>: Specifies the hook point (e.g., \"xdp\", \"kprobe\", \"tc\").</li> <li><code>license</code>: Required by the Linux kernel (e.g., \"GPL\").</li> <li>Contains local variable declarations (<code>reg</code>, <code>imm</code>, <code>heap</code>) and logic.</li> </ul>"},{"location":"language/units/#example","title":"Example","text":"<pre><code>unit filter_traffic {\n    section: \"xdp\";\n    license: \"GPL\";\n\n    return 1;\n}\n</code></pre>"},{"location":"overview/roadmap/","title":"Roadmap","text":""},{"location":"overview/roadmap/#phase-1-core-language-v0x","title":"Phase 1 \u2014 Core Language (v0.x)","text":"<ul> <li>Lexer and parser stabilization  </li> <li>Basic AST verification engine  </li> <li>eBPF instruction mapping layer  </li> <li>Minimal runtime sandbox model  </li> <li>Unit test framework integration  </li> </ul>"},{"location":"overview/roadmap/#phase-2-compiler-intelligence","title":"Phase 2 \u2014 Compiler Intelligence","text":"<ul> <li>Static program verification  </li> <li>Register allocation optimization  </li> <li>Memory safety validation rules  </li> <li>Pipeline optimization pass  </li> </ul>"},{"location":"overview/roadmap/#phase-3-kernel-interaction-layer","title":"Phase 3 \u2014 Kernel Interaction Layer","text":"<ul> <li>Advanced eBPF map abstraction  </li> <li>Network filter primitives  </li> <li>Security policy hooks  </li> <li>Event tracing modules  </li> <li>Performance telemetry collector  </li> </ul>"},{"location":"overview/roadmap/#phase-4-developer-experience","title":"Phase 4 \u2014 Developer Experience","text":"<ul> <li>CLI toolchain  </li> <li>Debugger support  </li> <li>Documentation generator  </li> </ul>"},{"location":"overview/roadmap/#future-vision","title":"Future Vision","text":"<ul> <li>Distributed eBPF execution model  </li> <li>Self-learning optimization compiler  </li> <li>Cross-platform kernel adaptation</li> </ul>"},{"location":"overview/why-solnix/","title":"Why Solnix? - Choosing a Safe eBPF Language","text":"<ul> <li>ebpf</li> <li>compiler</li> <li>rust</li> </ul>"},{"location":"overview/why-solnix/#why-solnix","title":"Why Solnix?","text":"<p>Solnix is designed for efficient eBPF program development with minimal verification overhead.</p>"},{"location":"overview/why-solnix/#lightweight-design","title":"Lightweight Design","text":"<ul> <li>Simple syntax  </li> <li>Compiler-level validation  </li> <li>Faster development cycle  </li> </ul>"},{"location":"overview/why-solnix/#ebpf-focus","title":"eBPF Focus","text":"<ul> <li>Kernel-level safe execution  </li> <li>Reduced program verification complexity  </li> <li>Performance oriented runtime model  </li> </ul>"},{"location":"overview/why-solnix/#productivity","title":"Productivity","text":"<p>Solnix helps developers write, test, and deploy eBPF programs faster with minimal tooling overhead.</p>"},{"location":"release-notes/","title":"Release Notes","text":"<p>Track the evolution of the Solnix language and compiler.</p>"},{"location":"release-notes/#latest-release","title":"Latest Release","text":""},{"location":"release-notes/#v020-safety-observability-2026-02-18","title":"v0.2.0 - Safety &amp; Observability (2026-02-18)","text":"<p>Introduces the <code>guard</code> pattern for pointer safety, full <code>if/else</code> support, and high-performance <code>ringbuf</code> implementation.</p>"},{"location":"release-notes/#past-releases","title":"Past Releases","text":""},{"location":"release-notes/#v010-the-genesis-2026-01-28","title":"v0.1.0 - The Genesis (2026-01-28)","text":"<p>The initial preview release. Basic tracepoint support, hash maps, and the core CLI tool.</p>"},{"location":"release-notes/#release-policy","title":"Release Policy","text":"<p>Solnix follows Semantic Versioning (SemVer). - Major: Breaking language changes or architectural rewrites. - Minor: New language features, new map types, or new helpers. - Patch: Bug fixes and compiler optimizations.</p>"},{"location":"release-notes/future/","title":"Roadmap","text":"<p>This page outlines the general direction of Solnix. Features may evolve as the compiler matures.</p>"},{"location":"release-notes/future/#language-improvements","title":"Language Improvements","text":"<ul> <li>Bounded loops compatible with the eBPF verifier</li> <li>Nested structures in <code>event</code> and <code>map</code></li> <li>Improved type checking and diagnostics</li> <li>Safer pointer analysis</li> </ul>"},{"location":"release-notes/future/#ebpf-integration","title":"eBPF Integration","text":"<ul> <li>Broader helper support</li> <li>LSM hook support</li> <li>CO-RE (BTF) compatibility</li> <li>Expanded program type coverage</li> </ul>"},{"location":"release-notes/future/#tooling","title":"Tooling","text":"<ul> <li>Language Server Protocol (LSP)</li> <li>Improved error diagnostics</li> <li>Formatter and linter tools</li> </ul>"},{"location":"release-notes/future/#long-term-vision","title":"Long-Term Vision","text":"<ul> <li>Stable v1.0 specification</li> <li>Comprehensive documentation</li> <li>Production-ready verifier guarantees</li> </ul>"},{"location":"release-notes/v0.1.0/","title":"Release v0.1.0 - The Genesis","text":"<p>Date: 2026-01-28 Release notes: View on GitHub</p>"},{"location":"release-notes/v0.1.0/#overview","title":"Overview","text":"<p>This is the initial preview release of the Solnix compiler, introducing a high-level DSL specifically designed for safe and efficient eBPF development on Linux.</p>"},{"location":"release-notes/v0.1.0/#key-features","title":"Key Features","text":""},{"location":"release-notes/v0.1.0/#language-core","title":"Language Core","text":"<ul> <li>Initial Parser &amp; Lexer: Support for basic Solnix syntax.</li> <li>Unit System: Introduction of <code>unit</code> as the primary program container.</li> <li>Register Variables: Support for <code>reg</code> declarations mapped to CPU registers.</li> <li>Standard Types: Support for <code>u32</code> and <code>u64</code> primitive types.</li> </ul>"},{"location":"release-notes/v0.1.0/#ebpf-infrastructure","title":"eBPF Infrastructure","text":"<ul> <li>Hash Maps: Support for defining persistent hash map structures in the kernel.</li> <li>Tracepoint Support: Initial hooks for kernel tracepoints.</li> <li>eBPF Section Generation: Automatic generation of standard ELF sections for eBPF objects.</li> </ul>"},{"location":"release-notes/v0.1.0/#tooling","title":"Tooling","text":"<ul> <li>solnixc CLI: Command-line interface for compiling <code>.snx</code> files into eBPF object files.</li> <li>Minimal Examples: Bundled examples to demonstrate basic tracing capabilities.</li> </ul>"},{"location":"release-notes/v0.2.0/","title":"Release v0.2.0 - Safety &amp; observability","text":"<p>Date: 2026-02-18 Release notes: View on GitHub</p>"},{"location":"release-notes/v0.2.0/#overview","title":"Overview","text":"<p>Release v0.2.0 introduces significant language enhancements focused on safety (guards), complex control flow (else blocks), and modernized networking support (Ring Buffer).</p>"},{"location":"release-notes/v0.2.0/#key-features","title":"Key Features","text":""},{"location":"release-notes/v0.2.0/#safety-control-flow","title":"Safety &amp; Control Flow","text":"<ul> <li>If/Else Support: Full support for conditional branching in units.</li> <li>Guard Pattern: Introduction of <code>if guard(ptr) { ... } else { ... }</code> for mandatory null-pointer verification, ensuring compatibility with the strict eBPF verifier.</li> </ul>"},{"location":"release-notes/v0.2.0/#updated-map-support","title":"Updated Map Support","text":"<ul> <li>Ring Buffer: Native support for high-performance <code>.ringbuf</code> maps.</li> <li>Dynamic Sizing: Ring buffer sizes are now dynamic rather than hardcoded.</li> <li>New Map Methods: <ul> <li><code>.update(key, val)</code></li> <li><code>.reserve(Event)</code></li> <li><code>.submit(ptr)</code></li> </ul> </li> </ul>"},{"location":"release-notes/v0.2.0/#advanced-observability","title":"Advanced Observability","text":"<ul> <li>Extended Context Helpers: Support for <code>get_current_comm</code>, <code>get_current_task</code>, and <code>get_ktime_ns</code>.</li> <li>Memory Probes: New <code>probe_read_user_str</code> and <code>probe_read_kernel_str</code> for safe string extraction from different memory spaces.</li> <li>Event Syntax: Introduction of <code>event { ... }</code> blocks for structured data transmission.</li> </ul>"},{"location":"release-notes/v0.2.0/#improvements-fixes","title":"Improvements &amp; Fixes","text":"<ul> <li>Diagnostics: Enhanced compiler error reporting with source location pointers.</li> <li>IR Stability: Improved robustness of the Intermediate Representation lowering phase.</li> <li>C Backend: More efficient C code generation for better kernel loader compatibility.</li> </ul>"}]}